import{c as w,g as E,r as i,j as m,R as P}from"./app-Bo4pM-9d.js";import{c as g}from"./button-B08klcT-.js";var x=w();const _=E(x);var y=["a","button","div","form","h2","h3","img","input","label","li","nav","ol","p","select","span","svg","ul"],M=y.reduce((e,o)=>{const t=g(`Primitive.${o}`),u=i.forwardRef((n,c)=>{const{asChild:s,...r}=n,a=s?t:o;return typeof window<"u"&&(window[Symbol.for("radix-ui")]=!0),m.jsx(a,{...r,ref:c})});return u.displayName=`Primitive.${o}`,{...e,[o]:u}},{});function A(e,o){e&&x.flushSync(()=>e.dispatchEvent(o))}function H(e,o,{checkForDefaultPrevented:t=!0}={}){return function(n){if(e?.(n),t===!1||!n.defaultPrevented)return o?.(n)}}function N(e,o){const t=i.createContext(o),u=c=>{const{children:s,...r}=c,a=i.useMemo(()=>r,Object.values(r));return m.jsx(t.Provider,{value:a,children:s})};u.displayName=e+"Provider";function n(c){const s=i.useContext(t);if(s)return s;if(o!==void 0)return o;throw new Error(`\`${c}\` must be used within \`${e}\``)}return[u,n]}function k(e,o=[]){let t=[];function u(c,s){const r=i.createContext(s),a=t.length;t=[...t,s];const d=f=>{const{scope:p,children:h,...v}=f,b=p?.[e]?.[a]||r,C=i.useMemo(()=>v,Object.values(v));return m.jsx(b.Provider,{value:C,children:h})};d.displayName=c+"Provider";function l(f,p){const h=p?.[e]?.[a]||r,v=i.useContext(h);if(v)return v;if(s!==void 0)return s;throw new Error(`\`${f}\` must be used within \`${c}\``)}return[d,l]}const n=()=>{const c=t.map(s=>i.createContext(s));return function(r){const a=r?.[e]||c;return i.useMemo(()=>({[`__scope${e}`]:{...r,[e]:a}}),[r,a])}};return n.scopeName=e,[u,R(n,...o)]}function R(...e){const o=e[0];if(e.length===1)return o;const t=()=>{const u=e.map(n=>({useScope:n(),scopeName:n.scopeName}));return function(c){const s=u.reduce((r,{useScope:a,scopeName:d})=>{const f=a(c)[`__scope${d}`];return{...r,...f}},{});return i.useMemo(()=>({[`__scope${o.scopeName}`]:s}),[s])}};return t.scopeName=o.scopeName,t}var S=globalThis?.document?i.useLayoutEffect:()=>{};function B(e){const[o,t]=i.useState(void 0);return S(()=>{if(e){t({width:e.offsetWidth,height:e.offsetHeight});const u=new ResizeObserver(n=>{if(!Array.isArray(n)||!n.length)return;const c=n[0];let s,r;if("borderBoxSize"in c){const a=c.borderBoxSize,d=Array.isArray(a)?a[0]:a;s=d.inlineSize,r=d.blockSize}else s=e.offsetWidth,r=e.offsetHeight;t({width:s,height:r})});return u.observe(e,{box:"border-box"}),()=>u.unobserve(e)}else t(void 0)},[e]),o}var $=P[" useInsertionEffect ".trim().toString()]||S;function F({prop:e,defaultProp:o,onChange:t=()=>{},caller:u}){const[n,c,s]=z({defaultProp:o,onChange:t}),r=e!==void 0,a=r?e:n;{const l=i.useRef(e!==void 0);i.useEffect(()=>{const f=l.current;f!==r&&console.warn(`${u} is changing from ${f?"controlled":"uncontrolled"} to ${r?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),l.current=r},[r,u])}const d=i.useCallback(l=>{if(r){const f=j(l)?l(e):l;f!==e&&s.current?.(f)}else c(l)},[r,e,c,s]);return[a,d]}function z({defaultProp:e,onChange:o}){const[t,u]=i.useState(e),n=i.useRef(t),c=i.useRef(o);return $(()=>{c.current=o},[o]),i.useEffect(()=>{n.current!==t&&(c.current?.(t),n.current=t)},[t,n]),[t,u,c]}function j(e){return typeof e=="function"}export{M as P,_ as R,H as a,S as b,k as c,B as d,A as e,N as f,x as r,F as u};
